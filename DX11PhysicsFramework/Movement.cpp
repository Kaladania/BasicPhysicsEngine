#include "Movement.h"

Movement::Movement(GameObject* parent) : Component(parent)
{
	_gravity = Vector3(0, -9.81f, 0); //sets gravity to be a downward force of 9.81
}

Movement::~Movement()
{
	_transform = nullptr;
}

/// <summary>
/// Translates an object in the requested direction
/// </summary>
/// <param name="transform">reference to object's transform</param>
/// <param name="direction">direction to translate the object</param>
void Movement::MoveTransform(Directions direction)
{
	Vector3 position = _transform->GetPosition(); //gets the objects current position

	Vector3 directionVector = Vector3(0, 0, 0.0f); //stores the new translation direction vector

	//customises the direction vector based on the requested direction
	switch (direction)
	{
	case Left:
		break;
	case Right:
		break;
	case Up:
		break;
	case Down:
		break;
	case Forwards:

		directionVector.z = -_movementSpeed;
		break;
	case Backwards:

		directionVector.z = _movementSpeed;
		break;
	default:
		break;
	}

	_velocity = directionVector;
}

Vector3 Movement::CalculateDisplacement(Vector3 displacement, float deltaTime)
{
	displacement = (_velocity * deltaTime) + ((_acceleration * (deltaTime * deltaTime)) * 0.5f);
	return displacement;
}

/// <summary>
/// Calculates the amount of drag applied to a floating object
/// </summary>
/// <returns>Current Drag Force</returns>
Vector3 Movement::CalculateDragForce()
{
	//gets the magnitude of the current velocity
	float velocityMagnitude = _vector3D->GetMagnitude(_velocity);
	
	//determines the scalar drag co-efficent
	float drag = DENSITY_OF_FLUID * ((velocityMagnitude * velocityMagnitude) * 0.5f) * DRAG_COEFFICIENT * CROSS_SECTIONAL_AREA;

	//creates a base drag force that is the negated normal of the current velocity
	//multiplies base opposing force by the drag scalar to determine the intensity of drag
	Vector3 dragForce = (_vector3D->Normalize(_velocity) * -1) * drag;

	//returns the total drag force
	return dragForce;
}

/// <summary>
/// Calculates the amount of friction opposing the movement
/// </summary>
/// <returns></returns>
Vector3 Movement::CalulateFrictionForce()
{
	//determines the force currently propelling the object
	Vector3 normalForce = _velocity * _mass;
	
	//returns the amount of friction generated by the movement
	return normalForce * FRICTION_COEFFICIENT;
}

void Movement::CalculateCollisionResolutionForce(const float otherCOR)
{
	_netForce = ((_velocity * -2.0f)) + (((_velocity * -2)) * _COR);
	_debugOutputer->PrintDebugString("Velocity is: " + _vector3D->ToString(_velocity));
	_velocity = Vector3(0, 0, 0);
}

void Movement::CalculateImpulse(Movement* otherMovement)
{
	//determines the collision normal
	//the direction between the centers of the colliding objects
	Vector3 collisionNormal = _vector3D->Normalize(_transform->GetPosition() - otherMovement->_transform->GetPosition());

	//gets the relative velocity of the current object with respect to the incoming object
	Vector3 relativeVelocity = _velocity - otherMovement->GetVeclocity();

	float collisionDotProduct = _vector3D->DotProduct(collisionNormal, relativeVelocity);
	_debugOutputer->PrintDebugString("Collision Dot Product is" + std::to_string(collisionDotProduct));

	if (collisionDotProduct > 0.0f)
	{
		//velocity impulse
		float vj = -(1 + RESTITUTION_COEFFICIENT) * collisionDotProduct;

		//calculates the total impulse applied in the collision
		float J = vj / ((1 / _mass) + (1 / otherMovement->GetMass()));
		
		//applies an impulse to the current object to propel it away from the other object
		ApplyImpulse(collisionNormal * (1 / _mass) * J);
		_debugOutputer->PrintDebugString("Object Impulse is" + _vector3D->ToString(collisionNormal * (1 / _mass) * J));

		//applies the same impulse in the reverse direction move the other object away from the current object
		ApplyImpulse((collisionNormal * J * (1 / otherMovement->GetMass())) * -1);
		_debugOutputer->PrintDebugString("Other Object Impulse is" +  _vector3D->ToString((collisionNormal * J * (1 / otherMovement->GetMass())) * -1));
	}

	//otherMovement->ApplyImpulse(Vector3(-10, 0, 0));
	////gets the direction between objects
	//Vector3 collisionNormal = _vector3D->Normalize(_transform->GetPosition() - otherPosition);

	//float restitution = 0; //hard coded for testing

	//Vector3 relativeVelocity = _velocity - otherMovement->GetVeclocity();

	//Vector3 vj = relativeVelocity * _vector3D->GetMagnitude((collisionNormal * (-(1 + restitution))));

	//Vector3 J = vj * ((-1 / _mass) + (-1 / otherMovement->GetMass()));

	//ApplyImpulse(_vector3D->CrossProduct(J * (-1 / _mass), collisionNormal));
	//ApplyImpulse((_vector3D->CrossProduct(J * (-1 / _mass), collisionNormal)) * -1);
}

void Movement::ApplyImpulse(Vector3 impulse)
{
	_velocity += impulse;
}

/// <summary>
/// Updates the position of the connected transform
/// </summary>
/// <param name="deltaTime">time elapsed since last physics update</param>
void Movement::Update(float deltaTime)
{
	if (!_isStationary)
	{
		//checks if the object is current simulating gravity
		if (_isSimulatingGravity)
		{
			_netForce += _gravity * _mass; //calculates the intensity of the gravitational force acting on the parent object
		}

		//calculates resistance force based on if object is suspended in air (not colliding) or moving along a surface (colliding)
		if (_isColliding)
		{
			//calculates the max value the friction scalar (intensity) should be to allow the object to move
			float maxFriction = _vector3D->GetMagnitude((_gravity * _mass) * STATIC_FRICTION_COEFFICIENT);

			//negates the netForce if the object does not have enough force to overcome friction (resets force applied to 0
			if (_vector3D->GetMagnitude(_netForce) < maxFriction)
			{
				_netForce = Vector3(0, 0, 0);
			}

			//calculates friction applied on a movement across a surface
			//applied even if static force is applied to ensure objects still decelerate if netForce drops below max while object is moving
			//e.g. if the propulsing force stops being applied
			_netForce -= CalulateFrictionForce();
		}
		else
		{
			//calculates drag applied ( air resistance )
			_netForce += CalculateDragForce();
		}


		_acceleration += _netForce / _mass; //calculates current rate of acceleration


		Vector3 position = _transform->GetPosition(); //gets the current position of the transform

		//calculates current velocity
		//v = u + at
		_velocity += _acceleration * deltaTime;

		//calculates the distance moved during this frame and updates position
		position += _velocity * deltaTime; 

		//hard coded stop to prevent falling through platform
		//REMOVE AFTER COLLISSION IS IMPLIMENTED
		if (_usesForcedFloor && position.y < 1)
		{
			position.y = 1;
			_isColliding = true;
		}
		else
		{
			_isColliding == false;
		}

		_transform->SetPosition(position); //sets new transform position

		//resets force values to maintain intergrity of calculations
		_netForce = Vector3(0, 0, 0);
		_acceleration = Vector3(0, 0, 0);
		_oldVelocity = _velocity;
		//_velocity = Vector3(0, 0, 0);
	}
}